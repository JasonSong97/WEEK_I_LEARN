# 📍Foreign Key

외래키는 데이터를 바인딩하는 것이다.

실제 업무에서는 `constraints`를 활용한다. `constraints`를 설정하므로서 SQL에 자동체크와 데이터를 보호한다.

여기서 데이터 보안(data security)이란 만약 1명의 고객이 여러 주문 데이터를 가지고 있는 경우가 있다고 가정하자.

실수로 주문 데이터를 삭제하고, 나중에 해당 데이터를 찾는 경우에는 절대로 찾을 수 없다. 하지만 `foreign key`를 사용하면 해당 문제를 효과적이면서 자동으로 피할 수 있다.

sample data

```sql
CREATE SCHEMA `new_schema` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

CREATE TABLE `new_schema`.`users` (
  `id` INT NOT NULL AUTO_INCREMENT COMMENT 'This is the primary index',
  `name` VARCHAR(45) NOT NULL DEFAULT 'N/A',
  `age` INT NULL,
  PRIMARY KEY (`id`)
);

INSERT INTO `new_schema`.`users` (`id`, `name`, `age`) VALUES 
  (1, 'John', 40),
  (2, 'May', 30),
  (3, 'Tim', 22);
  
  
CREATE TABLE `new_schema`.`orders` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `user_id` INT,
  `note` VARCHAR(255) NOT NULL,
  PRIMARY KEY (`id`)
);
 
INSERT INTO `new_schema`.`orders` (`id`, `user_id`, `note`) VALUES 
  (1, 1, 'some information'), 
  (2, 2, 'some comments'),
  (3, 2, 'no comments'),
  (4, 3, 'more comments');
```

![alt text](image/image-29.png)

## basic syntax & usage

```sql
ALTER TABLE `new_schema`.`orders`
    ADD CONSTRAINT `orders_user_id_key`
    FOREIGN KEY (`user_id`)
    REFERENCES `new_schema`.`users` (`id`);
```

- `ALTER TABLE`: 어떤 테이블을 설정할지
- `ADD CONSTRAINT`: 제약조건을 설정하고 싶은 이름앞에 붙이는 것, 우리는 `orders_user_id_key`에 제약조건을 적용
- `FOREIGN KEY`: 우리가 바인딩하고 싶은 테이블의 foreign key
- `references`: 어떤 외부 테이블과 묶이게 만들것인지, 여기서는 users 테이블의 id에 적용

### protection from delete

위에와 같은 조건을 만들면, 삭제를 보호할 수 있다.

```sql
DELETE FROM `new_schema`.`users` WHERE (`id` = `1`);
```

```text
ERROR 1451: 1451: Cannot delete or update a parent row: a foreign key constraint fails.
```

다음과 같이 에러메세지가 나온 이유는 `orders` 테이블의 `user_id`와 연결이 되어있기 때문에 나왔다.

### protection from update

```sql
UPDATE `new_shema`.`users` SET `id` = `6` WHERE (`id` = `1`);
```

```text
ERROR 1451: 1451: Cannot delete or update a parent row: a foreign key constraint fails
```

이것 또한 동일한 이유에서 에러가 발생한다. 하지만 아래의 경우 작동한다.

```sql
UPDATE `new_shema`.`users` SET `name` = `Tony` WHERE (`id` = `1`);
UPDATE `new_shema`.`users` SET `user_id` = `3` WHERE (`id` = `1`);
```

왜냐하면 제약조건을 위반하지 않기 때문에 수행이 가능하다.

### remove a constraint

```sql
ALTER TABLE `new_schema`.`orders`
    DROP FOREIGN KEY `orders_user_id_key`;
```

## diverse constraints

제약 조건을 생성할 때 `mode`를 지정하지 않으면 디폴트 `no action`으로 된다. `no action`의 경우 `mysql`의 `restrict` 모드와 동일하다. 

이 경우일 때는 `update` 또는 `delete`의 경우 에러를 발생시킨다.

## syntax

```sql
ALTER TABLE `new_schema`.`orders`
    ADD CONSTRAINT `orders_user_id_key`
    FOREIGN KEY(`user_id`)
    REFERENCES `new_schema`.`users` (`id`)
    ON DELETE NO ACTION
    ON UPDATE RESTRICT;
```

- `ON DELETE NO ACTION`: users행이 삭제되어도 참조키를 가지고 있는 orders의 행은 사라지지 않는 것
- `ON UPDATE RESTRICTS`: orders가 참조하고 있는 users의 행이 변경이 있어도 orders 테이블의 행을 업데이트하지 못함.

## referential Actions

제약조건에서 `no action`과 `restrict`는 `referential actions`라고 부른다.

추가적으로 sql에서는 다른 2가지 모드를 제공한다.

- `cascade`: 만약 user의 id가 6으로 변경이 되었다면, 자동으로 orders테이블의 user_id가 6으로 변경이 되는 것.

- `set null`: 만약 user의 id가 6으로 변경이 되었다면, orders 테이블의 user_id는 null로 변경이 되는 것.

[mysql foreign key constraints manual](https://dev.mysql.com/doc/refman/8.0/en/create-table-foreign-keys.html)

# 📍Transaction

# 📍ACID

# 📍Index

# 📍User Privilege